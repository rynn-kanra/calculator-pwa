var C={1:"P-256",2:"P-384",3:"P-521",6:"Ed25519",7:"Ed448"},E={"-7":"SHA-256","-35":"SHA-384","-36":"SHA-512","-257":"SHA-256","-258":"SHA-384","-259":"SHA-512"},p=new TextEncoder,v=new TextDecoder("utf-8");function B(F){let X=x(F);return v.decode(X)}function j(F){return p.encode(F)}async function c(F){let X=F[1],Z=F[3];switch(X){case 2:{let G=C[F["-1"]],Q=E[Z];if(!G||!Q)throw new Error("Unsupported EC curve or algorithm");let $={kty:"EC",crv:G,x:J(N(F[-2])),y:J(N(F[-3])),ext:!0,key_ops:["verify"]};return[await crypto.subtle.importKey("jwk",$,{name:"ECDSA",namedCurve:G},!0,["verify"]),{name:"ECDSA",hash:{name:Q}}]}case 3:{let G=E[Z];if(!G)throw new Error("Unsupported RSA algorithm");let Q={kty:"RSA",n:J(N(F[-1])),e:J(N(F[-2])),alg:`RS${G.split("-")[1]}`,ext:!0,key_ops:["verify"]},$={name:"RSASSA-PKCS1-v1_5",hash:{name:G}};return[await crypto.subtle.importKey("jwk",Q,$,!0,["verify"]),$]}case 1:{let G=C[F[-1]],Q=F[-2];if(!G)throw new Error("Unsupported OKP curve");let $={name:G};return[await crypto.subtle.importKey("raw",new Uint8Array(Q),$,!0,["verify"]),$]}}throw new Error(`Unsupported key type (kty: ${X})`)}function J(F){return F.replaceAll("+","-").replaceAll("/","_").replace(/=+$/,"")}function A(F){let X="=".repeat((4-F.length%4)%4);return(F+X).replaceAll("-","+").replaceAll("_","/")}function x(F){if(F instanceof Uint8Array)return F;if(ArrayBuffer.isView(F))return new Uint8Array(F.buffer,F.byteOffset,F.byteLength);return new Uint8Array(F)}function y(F,X=32){let Z=x(F),G=0;if(Z[G++]!==48)throw new Error("Invalid DER format");let Q=Z[G++];if(Q&128){let Y=Q&127;Q=0;for(let M=0;M<Y;M++)Q=Q<<8|Z[G++]}if(G+Q!==Z.length)throw new Error(`Invalid DER: declared length (${Q}) doesn't match actual length (${Z.length-G})`);if(Z[G++]!==2)throw new Error("Invalid R marker");let q=Z[G++],H=Z.slice(G+(q<X?0:q-X),G+q);if(G+=q,Z[G++]!==2)throw new Error("Invalid S marker");let W=Z[G++],D=Z.slice(G+(W<X?0:W-X),G+W);if(G+=W,G!==Z.length)throw new Error("Invalid DER: extra bytes after s-value");let T=new Uint8Array(X),I=new Uint8Array(X);return T.set(H,X-H.length),I.set(D,X-D.length),new Uint8Array([...T,...I])}function l(F,X){if(F.byteLength!==X.byteLength)return!1;let Z=F instanceof ArrayBuffer?new Uint8Array(F):new Uint8Array(F.buffer,F.byteOffset,F.byteLength),G=X instanceof ArrayBuffer?new Uint8Array(X):new Uint8Array(X.buffer,X.byteOffset,X.byteLength);for(let Q=0;Q<Z.length;Q++)if(Z[Q]!==G[Q])return!1;return!0}function O(...F){let X=F.map((Q)=>Q instanceof ArrayBuffer||ArrayBuffer.isView(Q)?x(Q):Q),Z=new Uint8Array(X.map((Q)=>Q.length).reduce((Q,$)=>Q+$,0)),G=0;for(let Q of X)Z.set(Q,G),G+=Q.length;return Z}function k(F){let X=atob(F),Z=X.length,G=new Uint8Array(Z);for(let Q=0;Q<Z;Q++)G[Q]=X.charCodeAt(Q);return G}function N(F){let X=x(F),Z="";for(let G=0;G<X.length;G++)Z+=String.fromCharCode(X[G]);return btoa(Z)}function S(F,X){let Z=x(F);if(Z[0]!==4)throw new Error("publicKey must be raw/uncompressed");return{kty:"EC",crv:"P-256",x:J(N(Z.slice(1,33))),y:J(N(Z.slice(33,65))),d:X,ext:!0}}async function d(F,X){let Z=k(A(X));return[await crypto.subtle.importKey("jwk",S(Z,F),{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),{name:"ECDSA",hash:{name:"SHA-256"}}]}async function n(F,X,Z,G){let Q=new URL(F).origin,$=Math.floor(Date.now()/1000),q=$+43200,H={typ:"JWT",alg:"ES256"},W={iat:$,aud:Q,exp:q,sub:X},D=J(N(j(JSON.stringify(H)))),T=J(N(j(JSON.stringify(W)))),I=`${D}.${T}`,Y=await crypto.subtle.sign(G,Z,j(I)),M=J(N(Y));return`${I}.${M}`}async function _(F,X,Z,G){let Q=await crypto.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:Z,info:X},F,G*8);return new Uint8Array(Q)}async function b(F,X,Z){let G=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveBits"]),Q=new Uint8Array(await crypto.subtle.exportKey("raw",G.publicKey)),$=J(N(Q));if(!Z)return{body:new Uint8Array(0),salt:new Uint8Array(0),serverPublicKeyB64u:$};let q=k(A(F)),H=await crypto.subtle.importKey("jwk",S(q),{name:"ECDH",namedCurve:"P-256"},!0,[]),W=await crypto.subtle.deriveBits({name:"ECDH",public:H},G.privateKey,256),D=await crypto.subtle.importKey("raw",W,{name:"HKDF"},!1,["deriveBits","deriveKey"]),T=k(A(X)),I=await _(D,j("Content-Encoding: auth\x00"),T,32),Y=await crypto.subtle.importKey("raw",I,{name:"HKDF"},!1,["deriveBits"]),M=O(j("P-256\x00"),new Uint8Array([q.byteLength>>8&255,q.byteLength&255]),q,new Uint8Array([Q.byteLength>>8&255,Q.byteLength&255]),Q),L=crypto.getRandomValues(new Uint8Array(16)),V=O(j("Content-Encoding: aesgcm\x00"),M),m=await _(Y,V,L,16),z=O(j("Content-Encoding: nonce\x00"),M),U=await _(Y,z,L,12),P=j(Z),R=0,g=new Uint8Array(R),h=O(new Uint8Array([R>>8&255,R&255]),g,P),K=await crypto.subtle.importKey("raw",m,{name:"AES-GCM"},!1,["encrypt"]);return{body:new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv:U},K,h)),salt:J(N(L)),serverPublicKeyB64u:$}}
export{B as t,j as u,c as v,J as w,A as x,x as y,y as z,l as A,O as B,k as C,N as D,d as E,n as F,b as G};
